<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: makeBloom user manual</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">makeBloom user manual </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Reads a <code>fasta</code> file, creates a bloom filter with a predefined:</p><ul>
<li>size (bits).</li>
<li>number of hash functions.</li>
<li>false positive rate. and saves it to a file.</li>
</ul>
<h2>Running the program</h2>
<p>Usage <code>C</code> executable (in folder <code>bin</code>):</p>
<div class="fragment"><div class="line">Usage: ./makeBloom --fasta &lt;FASTA_INPUT&gt; --output &lt;FILTERFILE&gt; --kmersize [KMERSIZE] </div><div class="line"> (--fal_pos_rate [p] | --hashNum [HASHNUM] | --bfsizeBits [SIZEBITS])</div><div class="line">Options: </div><div class="line"> -v, --version      Prints package version.</div><div class="line"> -h, --help         Prints help dialog.</div><div class="line"> -f, --fasta        Fasta input file. Mandatory option.</div><div class="line"> -o, --output       Output file, with NO extension. Mandatory option.</div><div class="line"> -k, --kmersize     kmer size, number or elements. Optional(default = 25)</div><div class="line"> -p, --fal_pos_rate false positive rate. Optional (default = 0.05)</div><div class="line"> -g, --hashNum      number of hash functions used. Optional (default</div><div class="line">                    value computed from the false positive rate).</div><div class="line"> -m, --bfsizeBits   size of the filter in bits. It will be forced to be</div><div class="line">                    a multiple of 8. Optional (default value computed</div><div class="line">                    from the false positive rate).</div><div class="line">NOTE: the options -p, -n, -m are mutually exclusive. The program </div><div class="line">      will give an error if more than one of them are passed as input.</div><div class="line">      It is recommended to pass the false positive rate and let the </div><div class="line">      program compute the other variables (excepting singular situations)</div><div class="line">      If none of them are passed, the false positive rate will default</div><div class="line">      to 0.05 and the other variables will be computed respecting this</div><div class="line">      requirement. See documentation and supplementary material for </div><div class="line">      more details.</div></div><!-- fragment --><h2>Output description</h2>
<p>Two files are created as output:</p><ul>
<li><code>&lt;FILTERFILE&gt;.bf</code>: contains the filter (binary file).</li>
<li><code>&lt;FILTERFILE&gt;.txt</code>: contains the following information:<ul>
<li><code>kmersize</code>: length of the kmers inserted in the filter,</li>
<li><code>bfsizeBits</code>: size of Bloom filter in bits,</li>
<li><code>hashNum</code>: number of hash functions used in the filter,</li>
<li><code>falsePosRate:</code> false positive rate,</li>
<li><code>nelem</code>: number of elemens (kmers in the sequece) contained in the filter.</li>
</ul>
</li>
</ul>
<p>For further details, read the <code>Doxygen</code> documentation of the files <code>bloom.c</code>, <code>init_makeBloom.c</code>, <code>makeBloom.c</code></p>
<h2>Example</h2>
<p>In the folder <code>../examples/bloomROC/</code> an example script can be run to test the bloom filter performance. <br />
 - The fastq files:</p><ul>
<li><code>human_reads.fq.gz</code></li>
<li><code>EColi_reads.fq.gz</code> are analyzed. They contain 10e5 reads each generated with <code>dgwsim</code>.</li>
</ul>
<p>STEP1: Create bloom filters for EColi genome with FPR: <code>[0.005 0.0075 0.01 0.02]</code> <br />
</p><ul>
<li>STEP2: Run trimFilter on both data looking for contaminations from EColi using all filters generated, with <code>kmersize = 25</code> and scores ranging from <code>0.05</code> to <code>0.2</code> by <code>0.01</code> intervals. We obtain false/true positive/negative rates:<ul>
<li>FPR: % contaminations detected in human_reads.fq.gz</li>
<li>TNR (specificity): % good reads detected in <code>human_reads.fq.gz</code></li>
<li>FNR: % good reads detected in <code>EColi_reads.fq.gz</code></li>
<li>TPR (sensitivity): % contaminations detected in <code>EColi_reads.fq.gz</code></li>
</ul>
</li>
<li>STEP3: Create ROC curves for all filters (sensitivity vs FPR). <br />
 The results (<code>*csv</code>, <code>*pdf</code>) can be compared with <code>example*pdf</code>, and <code>example*csv</code> in the folder (see example for <code>-p = 0.0075</code> below).</li>
</ul>
<div class="image">
<img src="./pics/ROC_0p0075_bloom.png" alt="noimage" title="ROC plots"/>
</div>
 <h2>Details on bloom filters</h2>
<p><b>NOTE</b>: For further details, read the <code>Doxygen</code> documentation of the files <code>bloom.c</code>, <code>init_makeBloom.c</code>, <code>makeBloom.c</code> and the supplementary material.</p>
<p>A bloom filter is a probabilistic data structure used to test if an element is a member of a set. False positive matches are possible but false negative are not. For a given set of <code>n</code> elements, we proceed as follows:</p>
<ul>
<li>decide on the number <code>g</code> of hash functions we will use for the construction of the filter and the length of the filter <code>m</code> (number of bits). This choice will be made based on the false positive rate we want to achieve (see Parameters)</li>
<li>we create an empty bloom filter, <code>B</code>, i.e. an array of <code>m</code> bits set to <code>0</code>. For every element in the set, <b>s<sub>&alpha;</sub> &isin; S</b>, compute the <code>g</code> hash functions, <b>H<sub>i</sub> (s<sub>&alpha;</sub>) &forall; i &isin; {1,...,g}</b> and set the corresponding bits to <code>1</code> in the filter, i.e., <b>B[H<sub>i</sub> (s<sub>&alpha;</sub>) mod m] = 1 &forall; i &isin; {1,...,g}</b> and <code>0</code> otherwise.</li>
</ul>
<p>Then, if we want to check whether an element <b>s<sub>&beta;</sub></b> is in the set <b>S</b>, we compute <b>H<sub>i</sub> (s<sub>&beta;</sub>) &forall; i &isin; {1,...,g}</b> and check whether all coresponding positions in the filter are set to <code>1</code>, in which case we can say that <b>s<sub>&beta;</sub></b> might be in the set. Otherwise it is definitely not in the set.</p>
<h3>Parameters.</h3>
<p>We choose the parameters so that the desired false positive rate is achieved. Alternatively, we can pass the filter size, and then the number of hash functions to be used is tuned so that the false positive rate is minimized.</p>
<p>We assume the hash functions select all positions with the same probability. The probability that an bit in the filter <code>B</code> is not set to <code>1</code> after inserting an element using <code>g</code> hash functions is:</p>
<p><b> (1 - <sup>1</sup>&frasl;<sub>m</sub>)<sup>g</sup> </b></p>
<p>where <code>m</code> is the number of bits of the filter. If we insert <code>n</code> elements, the probability that an element is still 0 is:</p>
<p><b> p<sub>0</sub> = (1 - <sup>1</sup>&frasl;<sub>m</sub>)<sup>gn</sup> </b></p>
<p>The probability that a bit is <code>1</code> is then,</p>
<p><b> p<sub>1</sub> = 1 - (1 - <sup>1</sup>&frasl;<sub>m</sub>)<sup>gn</sup> </b></p>
<p>Now, let's compute the false positive rate, i.e., that probability that an element that is not in the set is classified as belonging to it. This is the probability that all positions computed from the hash functions being <code>1</code> is,</p>
<p><b> p(g, n, m) = (1 - (1 - <sup>1</sup>&frasl;<sub>m</sub>)<sup>gn</sup>)<sup>g</sup> = (1 - e<sup> - <sup>gn</sup>&frasl;<sub>m</sub> </sup>)<sup>g</sup> </b></p>
<p>For a given <code>n</code> and <code>m</code> the value of <code>g</code> that minimizes <code>p</code> is,</p>
<p><b> <sup>dp(g, n, m)</sup>&frasl;<sub>dg</sub> = 0 &rArr; g = <sup>m</sup>&frasl;<sub>n</sub> log(2) </b></p>
<p>The required number of bits <code>m</code> for the desired positive rate given <code>n</code> number of elements and assuming the optimal number of hash functions being used is,</p>
<p><b> m = - <sup>n log (p)</sup>&frasl;<sub>log<sup>2</sup>(2)</sub>. </b></p>
<h3>Creating a bloom filter from a <code>fasta</code> file</h3>
<p>Given a <code>fasta</code> file, the elements to be inserted in the bloom filter are all possible <code>k</code>-mers contained in the <code>fasta</code> file. The length <code>k</code> of the <code>k</code>-mers can be given by the user as an input parameter and is chosen to be <code>25</code> by default. All <code>k</code>-mers containing nucleotides different from <code>{A,C,G,T}</code> will not be consiedered and they are encoded such that every nucleotide takes only 2-bits memory. Wee look into the reverse complement and insert only the one that is lexycographically smaller.</p>
<p>Once the <code>k</code>-mer has been processed, the hash functions are computed an the positions of the output values are set to <code>1</code> in the filter.</p>
<h3>Checking ir a read in a <code>fastq</code> file is in the filter</h3>
<p>To check whether a <code>fastq</code> read of length <code>L</code> is in the filter, we proceed as follows:</p>
<ol type="1">
<li>Start with a score <code>score = 0</code>.</li>
<li>Construct and process all <code>k</code>-mers of length <code>k</code> in the read, <code>(L - k + 1)</code> (note that <code>L</code>&ge;<code>k</code>)</li>
<li>For each <code>k</code>-mer, compute the <code>g</code> hash functions and check whether all bits in the corresponding positions in the filter are set to <code>1</code>. If so, add **<sup>1</sup>&frasl;<sub>(L - k + 1)</sub>** to the score.</li>
</ol>
<p>If the score is above the user predefined threshold (<code>-s</code>), the read is classified as belonging to the set, and not otherwise.</p>
<h3>Memory usage, sensitivity and specificity</h3>
<p>The <b>memory usage</b> will be determined by <code>m</code>, the size of the filter. The optimal number of bits per element is</p>
<p><b> <sup>m</sup>&frasl;<sub>n</sub> = - <sup> log (p)</sup>&frasl; <sub>log<sup>2</sup>(2)</sub>. </b></p>
<p>In the figures below, we can see both, the optimal number of bits per element and the optimal number of hash functions as a function of the false positive rate.</p>
<div class="image">
<img src="./pics/bloomfilter.png" alt="noimage" title="FDR plots"/>
</div>
 <p>As an example, let's assume we want to look for contaminations in a genome <code>~3GB</code> and want to keep the false positive rate by <code>2%</code>. Then, we will need a filter of <code>~3.05GB</code>.</p>
<p><b>Sensitivity</b> (true positive rate, TP/(TP + FN)) can be increased by decreasing the <code>k</code>-mer size (<code>-k</code>) and the score threshold. False negatives only occur in the presence of mismatches due to variants, or errors in the base calling procedure, since the filter itself does not allow for false negatives.</p>
<p>To increase <b>specificity</b> (true negative rate, TN/(TN + FP)), you can increase the score threshold (<code>-s</code>) or, obviously reduce the positive rate, (<code>-p</code>).</p>
<h2>Contributors</h2>
<p>Paula Pérez Rubio</p>
<h2>License</h2>
<p>GPL v3 (see LICENSE.txt) </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
